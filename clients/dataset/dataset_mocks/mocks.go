// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package dataset_mocks

import (
	"context"
	"io"
	"net/http"
	"net/url"
	"sync"
)

var (
	lockRCHTTPClientMockDo       sync.RWMutex
	lockRCHTTPClientMockGet      sync.RWMutex
	lockRCHTTPClientMockHead     sync.RWMutex
	lockRCHTTPClientMockPost     sync.RWMutex
	lockRCHTTPClientMockPostForm sync.RWMutex
)

// RCHTTPClientMock is a mock implementation of RCHTTPClient.
//
//     func TestSomethingThatUsesRCHTTPClient(t *testing.T) {
//
//         // make and configure a mocked RCHTTPClient
//         mockedRCHTTPClient := &RCHTTPClientMock{
//             DoFunc: func(ctx context.Context, req *http.Request) (*http.Response, error) {
// 	               panic("TODO: mock out the Do method")
//             },
//             GetFunc: func(ctx context.Context, url string) (*http.Response, error) {
// 	               panic("TODO: mock out the Get method")
//             },
//             HeadFunc: func(ctx context.Context, url string) (*http.Response, error) {
// 	               panic("TODO: mock out the Head method")
//             },
//             PostFunc: func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
// 	               panic("TODO: mock out the Post method")
//             },
//             PostFormFunc: func(ctx context.Context, uri string, data url.Values) (*http.Response, error) {
// 	               panic("TODO: mock out the PostForm method")
//             },
//         }
//
//         // TODO: use mockedRCHTTPClient in code that requires RCHTTPClient
//         //       and then make assertions.
//
//     }
type RCHTTPClientMock struct {
	// DoFunc mocks the Do method.
	DoFunc func(ctx context.Context, req *http.Request) (*http.Response, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, url string) (*http.Response, error)

	// HeadFunc mocks the Head method.
	HeadFunc func(ctx context.Context, url string) (*http.Response, error)

	// PostFunc mocks the Post method.
	PostFunc func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error)

	// PostFormFunc mocks the PostForm method.
	PostFormFunc func(ctx context.Context, uri string, data url.Values) (*http.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// Do holds details about calls to the Do method.
		Do []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *http.Request
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
		}
		// Head holds details about calls to the Head method.
		Head []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
		}
		// Post holds details about calls to the Post method.
		Post []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
			// ContentType is the contentType argument value.
			ContentType string
			// Body is the body argument value.
			Body io.Reader
		}
		// PostForm holds details about calls to the PostForm method.
		PostForm []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URI is the uri argument value.
			URI string
			// Data is the data argument value.
			Data url.Values
		}
	}
}

// Do calls DoFunc.
func (mock *RCHTTPClientMock) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
	if mock.DoFunc == nil {
		panic("moq: RCHTTPClientMock.DoFunc is nil but RCHTTPClient.Do was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *http.Request
	}{
		Ctx: ctx,
		Req: req,
	}
	lockRCHTTPClientMockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	lockRCHTTPClientMockDo.Unlock()
	return mock.DoFunc(ctx, req)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//     len(mockedRCHTTPClient.DoCalls())
func (mock *RCHTTPClientMock) DoCalls() []struct {
	Ctx context.Context
	Req *http.Request
} {
	var calls []struct {
		Ctx context.Context
		Req *http.Request
	}
	lockRCHTTPClientMockDo.RLock()
	calls = mock.calls.Do
	lockRCHTTPClientMockDo.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *RCHTTPClientMock) Get(ctx context.Context, url string) (*http.Response, error) {
	if mock.GetFunc == nil {
		panic("moq: RCHTTPClientMock.GetFunc is nil but RCHTTPClient.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		URL string
	}{
		Ctx: ctx,
		URL: url,
	}
	lockRCHTTPClientMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockRCHTTPClientMockGet.Unlock()
	return mock.GetFunc(ctx, url)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedRCHTTPClient.GetCalls())
func (mock *RCHTTPClientMock) GetCalls() []struct {
	Ctx context.Context
	URL string
} {
	var calls []struct {
		Ctx context.Context
		URL string
	}
	lockRCHTTPClientMockGet.RLock()
	calls = mock.calls.Get
	lockRCHTTPClientMockGet.RUnlock()
	return calls
}

// Head calls HeadFunc.
func (mock *RCHTTPClientMock) Head(ctx context.Context, url string) (*http.Response, error) {
	if mock.HeadFunc == nil {
		panic("moq: RCHTTPClientMock.HeadFunc is nil but RCHTTPClient.Head was just called")
	}
	callInfo := struct {
		Ctx context.Context
		URL string
	}{
		Ctx: ctx,
		URL: url,
	}
	lockRCHTTPClientMockHead.Lock()
	mock.calls.Head = append(mock.calls.Head, callInfo)
	lockRCHTTPClientMockHead.Unlock()
	return mock.HeadFunc(ctx, url)
}

// HeadCalls gets all the calls that were made to Head.
// Check the length with:
//     len(mockedRCHTTPClient.HeadCalls())
func (mock *RCHTTPClientMock) HeadCalls() []struct {
	Ctx context.Context
	URL string
} {
	var calls []struct {
		Ctx context.Context
		URL string
	}
	lockRCHTTPClientMockHead.RLock()
	calls = mock.calls.Head
	lockRCHTTPClientMockHead.RUnlock()
	return calls
}

// Post calls PostFunc.
func (mock *RCHTTPClientMock) Post(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
	if mock.PostFunc == nil {
		panic("moq: RCHTTPClientMock.PostFunc is nil but RCHTTPClient.Post was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}{
		Ctx:         ctx,
		URL:         url,
		ContentType: contentType,
		Body:        body,
	}
	lockRCHTTPClientMockPost.Lock()
	mock.calls.Post = append(mock.calls.Post, callInfo)
	lockRCHTTPClientMockPost.Unlock()
	return mock.PostFunc(ctx, url, contentType, body)
}

// PostCalls gets all the calls that were made to Post.
// Check the length with:
//     len(mockedRCHTTPClient.PostCalls())
func (mock *RCHTTPClientMock) PostCalls() []struct {
	Ctx         context.Context
	URL         string
	ContentType string
	Body        io.Reader
} {
	var calls []struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}
	lockRCHTTPClientMockPost.RLock()
	calls = mock.calls.Post
	lockRCHTTPClientMockPost.RUnlock()
	return calls
}

// PostForm calls PostFormFunc.
func (mock *RCHTTPClientMock) PostForm(ctx context.Context, uri string, data url.Values) (*http.Response, error) {
	if mock.PostFormFunc == nil {
		panic("moq: RCHTTPClientMock.PostFormFunc is nil but RCHTTPClient.PostForm was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		URI  string
		Data url.Values
	}{
		Ctx:  ctx,
		URI:  uri,
		Data: data,
	}
	lockRCHTTPClientMockPostForm.Lock()
	mock.calls.PostForm = append(mock.calls.PostForm, callInfo)
	lockRCHTTPClientMockPostForm.Unlock()
	return mock.PostFormFunc(ctx, uri, data)
}

// PostFormCalls gets all the calls that were made to PostForm.
// Check the length with:
//     len(mockedRCHTTPClient.PostFormCalls())
func (mock *RCHTTPClientMock) PostFormCalls() []struct {
	Ctx  context.Context
	URI  string
	Data url.Values
} {
	var calls []struct {
		Ctx  context.Context
		URI  string
		Data url.Values
	}
	lockRCHTTPClientMockPostForm.RLock()
	calls = mock.calls.PostForm
	lockRCHTTPClientMockPostForm.RUnlock()
	return calls
}
