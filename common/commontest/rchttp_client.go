// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package commontest

import (
	"context"
	"io"
	"net/http"
	"net/url"
	"sync"
	"time"
)

var (
	lockRCHTTPClientMockDo            sync.RWMutex
	lockRCHTTPClientMockGet           sync.RWMutex
	lockRCHTTPClientMockGetMaxRetries sync.RWMutex
	lockRCHTTPClientMockHead          sync.RWMutex
	lockRCHTTPClientMockPost          sync.RWMutex
	lockRCHTTPClientMockPostForm      sync.RWMutex
	lockRCHTTPClientMockPut           sync.RWMutex
	lockRCHTTPClientMockSetAuthToken  sync.RWMutex
	lockRCHTTPClientMockSetMaxRetries sync.RWMutex
	lockRCHTTPClientMockSetTimeout    sync.RWMutex
)

// RCHTTPClientMock is a mock implementation of RCHTTPClient.
//
//     func TestSomethingThatUsesRCHTTPClient(t *testing.T) {
//
//         // make and configure a mocked RCHTTPClient
//         mockedRCHTTPClient := &RCHTTPClientMock{
//             DoFunc: func(ctx context.Context, req *http.Request) (*http.Response, error) {
// 	               panic("TODO: mock out the Do method")
//             },
//             GetFunc: func(ctx context.Context, url string) (*http.Response, error) {
// 	               panic("TODO: mock out the Get method")
//             },
//             GetMaxRetriesFunc: func() int {
// 	               panic("TODO: mock out the GetMaxRetries method")
//             },
//             HeadFunc: func(ctx context.Context, url string) (*http.Response, error) {
// 	               panic("TODO: mock out the Head method")
//             },
//             PostFunc: func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
// 	               panic("TODO: mock out the Post method")
//             },
//             PostFormFunc: func(ctx context.Context, uri string, data url.Values) (*http.Response, error) {
// 	               panic("TODO: mock out the PostForm method")
//             },
//             PutFunc: func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
// 	               panic("TODO: mock out the Put method")
//             },
//             SetAuthTokenFunc: func(authToken string)  {
// 	               panic("TODO: mock out the SetAuthToken method")
//             },
//             SetMaxRetriesFunc: func(in1 int)  {
// 	               panic("TODO: mock out the SetMaxRetries method")
//             },
//             SetTimeoutFunc: func(timeout time.Duration)  {
// 	               panic("TODO: mock out the SetTimeout method")
//             },
//         }
//
//         // TODO: use mockedRCHTTPClient in code that requires RCHTTPClient
//         //       and then make assertions.
//
//     }
type RCHTTPClientMock struct {
	// DoFunc mocks the Do method.
	DoFunc func(ctx context.Context, req *http.Request) (*http.Response, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, url string) (*http.Response, error)

	// GetMaxRetriesFunc mocks the GetMaxRetries method.
	GetMaxRetriesFunc func() int

	// HeadFunc mocks the Head method.
	HeadFunc func(ctx context.Context, url string) (*http.Response, error)

	// PostFunc mocks the Post method.
	PostFunc func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error)

	// PostFormFunc mocks the PostForm method.
	PostFormFunc func(ctx context.Context, uri string, data url.Values) (*http.Response, error)

	// PutFunc mocks the Put method.
	PutFunc func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error)

	// SetAuthTokenFunc mocks the SetAuthToken method.
	SetAuthTokenFunc func(authToken string)

	// SetMaxRetriesFunc mocks the SetMaxRetries method.
	SetMaxRetriesFunc func(in1 int)

	// SetTimeoutFunc mocks the SetTimeout method.
	SetTimeoutFunc func(timeout time.Duration)

	// calls tracks calls to the methods.
	calls struct {
		// Do holds details about calls to the Do method.
		Do []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *http.Request
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
		}
		// GetMaxRetries holds details about calls to the GetMaxRetries method.
		GetMaxRetries []struct {
		}
		// Head holds details about calls to the Head method.
		Head []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
		}
		// Post holds details about calls to the Post method.
		Post []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
			// ContentType is the contentType argument value.
			ContentType string
			// Body is the body argument value.
			Body io.Reader
		}
		// PostForm holds details about calls to the PostForm method.
		PostForm []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URI is the uri argument value.
			URI string
			// Data is the data argument value.
			Data url.Values
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
			// ContentType is the contentType argument value.
			ContentType string
			// Body is the body argument value.
			Body io.Reader
		}
		// SetAuthToken holds details about calls to the SetAuthToken method.
		SetAuthToken []struct {
			// AuthToken is the authToken argument value.
			AuthToken string
		}
		// SetMaxRetries holds details about calls to the SetMaxRetries method.
		SetMaxRetries []struct {
			// In1 is the in1 argument value.
			In1 int
		}
		// SetTimeout holds details about calls to the SetTimeout method.
		SetTimeout []struct {
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
	}
}

// Do calls DoFunc.
func (mock *RCHTTPClientMock) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
	if mock.DoFunc == nil {
		panic("moq: RCHTTPClientMock.DoFunc is nil but RCHTTPClient.Do was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *http.Request
	}{
		Ctx: ctx,
		Req: req,
	}
	lockRCHTTPClientMockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	lockRCHTTPClientMockDo.Unlock()
	return mock.DoFunc(ctx, req)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//     len(mockedRCHTTPClient.DoCalls())
func (mock *RCHTTPClientMock) DoCalls() []struct {
	Ctx context.Context
	Req *http.Request
} {
	var calls []struct {
		Ctx context.Context
		Req *http.Request
	}
	lockRCHTTPClientMockDo.RLock()
	calls = mock.calls.Do
	lockRCHTTPClientMockDo.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *RCHTTPClientMock) Get(ctx context.Context, url string) (*http.Response, error) {
	if mock.GetFunc == nil {
		panic("moq: RCHTTPClientMock.GetFunc is nil but RCHTTPClient.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		URL string
	}{
		Ctx: ctx,
		URL: url,
	}
	lockRCHTTPClientMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockRCHTTPClientMockGet.Unlock()
	return mock.GetFunc(ctx, url)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedRCHTTPClient.GetCalls())
func (mock *RCHTTPClientMock) GetCalls() []struct {
	Ctx context.Context
	URL string
} {
	var calls []struct {
		Ctx context.Context
		URL string
	}
	lockRCHTTPClientMockGet.RLock()
	calls = mock.calls.Get
	lockRCHTTPClientMockGet.RUnlock()
	return calls
}

// GetMaxRetries calls GetMaxRetriesFunc.
func (mock *RCHTTPClientMock) GetMaxRetries() int {
	if mock.GetMaxRetriesFunc == nil {
		panic("moq: RCHTTPClientMock.GetMaxRetriesFunc is nil but RCHTTPClient.GetMaxRetries was just called")
	}
	callInfo := struct {
	}{}
	lockRCHTTPClientMockGetMaxRetries.Lock()
	mock.calls.GetMaxRetries = append(mock.calls.GetMaxRetries, callInfo)
	lockRCHTTPClientMockGetMaxRetries.Unlock()
	return mock.GetMaxRetriesFunc()
}

// GetMaxRetriesCalls gets all the calls that were made to GetMaxRetries.
// Check the length with:
//     len(mockedRCHTTPClient.GetMaxRetriesCalls())
func (mock *RCHTTPClientMock) GetMaxRetriesCalls() []struct {
} {
	var calls []struct {
	}
	lockRCHTTPClientMockGetMaxRetries.RLock()
	calls = mock.calls.GetMaxRetries
	lockRCHTTPClientMockGetMaxRetries.RUnlock()
	return calls
}

// Head calls HeadFunc.
func (mock *RCHTTPClientMock) Head(ctx context.Context, url string) (*http.Response, error) {
	if mock.HeadFunc == nil {
		panic("moq: RCHTTPClientMock.HeadFunc is nil but RCHTTPClient.Head was just called")
	}
	callInfo := struct {
		Ctx context.Context
		URL string
	}{
		Ctx: ctx,
		URL: url,
	}
	lockRCHTTPClientMockHead.Lock()
	mock.calls.Head = append(mock.calls.Head, callInfo)
	lockRCHTTPClientMockHead.Unlock()
	return mock.HeadFunc(ctx, url)
}

// HeadCalls gets all the calls that were made to Head.
// Check the length with:
//     len(mockedRCHTTPClient.HeadCalls())
func (mock *RCHTTPClientMock) HeadCalls() []struct {
	Ctx context.Context
	URL string
} {
	var calls []struct {
		Ctx context.Context
		URL string
	}
	lockRCHTTPClientMockHead.RLock()
	calls = mock.calls.Head
	lockRCHTTPClientMockHead.RUnlock()
	return calls
}

// Post calls PostFunc.
func (mock *RCHTTPClientMock) Post(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
	if mock.PostFunc == nil {
		panic("moq: RCHTTPClientMock.PostFunc is nil but RCHTTPClient.Post was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}{
		Ctx:         ctx,
		URL:         url,
		ContentType: contentType,
		Body:        body,
	}
	lockRCHTTPClientMockPost.Lock()
	mock.calls.Post = append(mock.calls.Post, callInfo)
	lockRCHTTPClientMockPost.Unlock()
	return mock.PostFunc(ctx, url, contentType, body)
}

// PostCalls gets all the calls that were made to Post.
// Check the length with:
//     len(mockedRCHTTPClient.PostCalls())
func (mock *RCHTTPClientMock) PostCalls() []struct {
	Ctx         context.Context
	URL         string
	ContentType string
	Body        io.Reader
} {
	var calls []struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}
	lockRCHTTPClientMockPost.RLock()
	calls = mock.calls.Post
	lockRCHTTPClientMockPost.RUnlock()
	return calls
}

// PostForm calls PostFormFunc.
func (mock *RCHTTPClientMock) PostForm(ctx context.Context, uri string, data url.Values) (*http.Response, error) {
	if mock.PostFormFunc == nil {
		panic("moq: RCHTTPClientMock.PostFormFunc is nil but RCHTTPClient.PostForm was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		URI  string
		Data url.Values
	}{
		Ctx:  ctx,
		URI:  uri,
		Data: data,
	}
	lockRCHTTPClientMockPostForm.Lock()
	mock.calls.PostForm = append(mock.calls.PostForm, callInfo)
	lockRCHTTPClientMockPostForm.Unlock()
	return mock.PostFormFunc(ctx, uri, data)
}

// PostFormCalls gets all the calls that were made to PostForm.
// Check the length with:
//     len(mockedRCHTTPClient.PostFormCalls())
func (mock *RCHTTPClientMock) PostFormCalls() []struct {
	Ctx  context.Context
	URI  string
	Data url.Values
} {
	var calls []struct {
		Ctx  context.Context
		URI  string
		Data url.Values
	}
	lockRCHTTPClientMockPostForm.RLock()
	calls = mock.calls.PostForm
	lockRCHTTPClientMockPostForm.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *RCHTTPClientMock) Put(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
	if mock.PutFunc == nil {
		panic("moq: RCHTTPClientMock.PutFunc is nil but RCHTTPClient.Put was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}{
		Ctx:         ctx,
		URL:         url,
		ContentType: contentType,
		Body:        body,
	}
	lockRCHTTPClientMockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	lockRCHTTPClientMockPut.Unlock()
	return mock.PutFunc(ctx, url, contentType, body)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//     len(mockedRCHTTPClient.PutCalls())
func (mock *RCHTTPClientMock) PutCalls() []struct {
	Ctx         context.Context
	URL         string
	ContentType string
	Body        io.Reader
} {
	var calls []struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}
	lockRCHTTPClientMockPut.RLock()
	calls = mock.calls.Put
	lockRCHTTPClientMockPut.RUnlock()
	return calls
}

// SetAuthToken calls SetAuthTokenFunc.
func (mock *RCHTTPClientMock) SetAuthToken(authToken string) {
	if mock.SetAuthTokenFunc == nil {
		panic("moq: RCHTTPClientMock.SetAuthTokenFunc is nil but RCHTTPClient.SetAuthToken was just called")
	}
	callInfo := struct {
		AuthToken string
	}{
		AuthToken: authToken,
	}
	lockRCHTTPClientMockSetAuthToken.Lock()
	mock.calls.SetAuthToken = append(mock.calls.SetAuthToken, callInfo)
	lockRCHTTPClientMockSetAuthToken.Unlock()
	mock.SetAuthTokenFunc(authToken)
}

// SetAuthTokenCalls gets all the calls that were made to SetAuthToken.
// Check the length with:
//     len(mockedRCHTTPClient.SetAuthTokenCalls())
func (mock *RCHTTPClientMock) SetAuthTokenCalls() []struct {
	AuthToken string
} {
	var calls []struct {
		AuthToken string
	}
	lockRCHTTPClientMockSetAuthToken.RLock()
	calls = mock.calls.SetAuthToken
	lockRCHTTPClientMockSetAuthToken.RUnlock()
	return calls
}

// SetMaxRetries calls SetMaxRetriesFunc.
func (mock *RCHTTPClientMock) SetMaxRetries(in1 int) {
	if mock.SetMaxRetriesFunc == nil {
		panic("moq: RCHTTPClientMock.SetMaxRetriesFunc is nil but RCHTTPClient.SetMaxRetries was just called")
	}
	callInfo := struct {
		In1 int
	}{
		In1: in1,
	}
	lockRCHTTPClientMockSetMaxRetries.Lock()
	mock.calls.SetMaxRetries = append(mock.calls.SetMaxRetries, callInfo)
	lockRCHTTPClientMockSetMaxRetries.Unlock()
	mock.SetMaxRetriesFunc(in1)
}

// SetMaxRetriesCalls gets all the calls that were made to SetMaxRetries.
// Check the length with:
//     len(mockedRCHTTPClient.SetMaxRetriesCalls())
func (mock *RCHTTPClientMock) SetMaxRetriesCalls() []struct {
	In1 int
} {
	var calls []struct {
		In1 int
	}
	lockRCHTTPClientMockSetMaxRetries.RLock()
	calls = mock.calls.SetMaxRetries
	lockRCHTTPClientMockSetMaxRetries.RUnlock()
	return calls
}

// SetTimeout calls SetTimeoutFunc.
func (mock *RCHTTPClientMock) SetTimeout(timeout time.Duration) {
	if mock.SetTimeoutFunc == nil {
		panic("moq: RCHTTPClientMock.SetTimeoutFunc is nil but RCHTTPClient.SetTimeout was just called")
	}
	callInfo := struct {
		Timeout time.Duration
	}{
		Timeout: timeout,
	}
	lockRCHTTPClientMockSetTimeout.Lock()
	mock.calls.SetTimeout = append(mock.calls.SetTimeout, callInfo)
	lockRCHTTPClientMockSetTimeout.Unlock()
	mock.SetTimeoutFunc(timeout)
}

// SetTimeoutCalls gets all the calls that were made to SetTimeout.
// Check the length with:
//     len(mockedRCHTTPClient.SetTimeoutCalls())
func (mock *RCHTTPClientMock) SetTimeoutCalls() []struct {
	Timeout time.Duration
} {
	var calls []struct {
		Timeout time.Duration
	}
	lockRCHTTPClientMockSetTimeout.RLock()
	calls = mock.calls.SetTimeout
	lockRCHTTPClientMockSetTimeout.RUnlock()
	return calls
}
