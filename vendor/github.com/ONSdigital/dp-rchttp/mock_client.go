// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package rchttp

import (
	"context"
	"io"
	"net/http"
	"net/url"
	"sync"
	"time"
)

var (
	lockClienterMockDo            sync.RWMutex
	lockClienterMockGet           sync.RWMutex
	lockClienterMockGetMaxRetries sync.RWMutex
	lockClienterMockHead          sync.RWMutex
	lockClienterMockPost          sync.RWMutex
	lockClienterMockPostForm      sync.RWMutex
	lockClienterMockPut           sync.RWMutex
	lockClienterMockSetMaxRetries sync.RWMutex
	lockClienterMockSetTimeout    sync.RWMutex
)

// Ensure, that ClienterMock does implement Clienter.
// If this is not the case, regenerate this file with moq.
var _ Clienter = &ClienterMock{}

// ClienterMock is a mock implementation of Clienter.
//
//     func TestSomethingThatUsesClienter(t *testing.T) {
//
//         // make and configure a mocked Clienter
//         mockedClienter := &ClienterMock{
//             DoFunc: func(ctx context.Context, req *http.Request) (*http.Response, error) {
// 	               panic("mock out the Do method")
//             },
//             GetFunc: func(ctx context.Context, url string) (*http.Response, error) {
// 	               panic("mock out the Get method")
//             },
//             GetMaxRetriesFunc: func() int {
// 	               panic("mock out the GetMaxRetries method")
//             },
//             HeadFunc: func(ctx context.Context, url string) (*http.Response, error) {
// 	               panic("mock out the Head method")
//             },
//             PostFunc: func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
// 	               panic("mock out the Post method")
//             },
//             PostFormFunc: func(ctx context.Context, uri string, data url.Values) (*http.Response, error) {
// 	               panic("mock out the PostForm method")
//             },
//             PutFunc: func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
// 	               panic("mock out the Put method")
//             },
//             SetMaxRetriesFunc: func(in1 int)  {
// 	               panic("mock out the SetMaxRetries method")
//             },
//             SetTimeoutFunc: func(timeout time.Duration)  {
// 	               panic("mock out the SetTimeout method")
//             },
//         }
//
//         // use mockedClienter in code that requires Clienter
//         // and then make assertions.
//
//     }
type ClienterMock struct {
	// DoFunc mocks the Do method.
	DoFunc func(ctx context.Context, req *http.Request) (*http.Response, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, url string) (*http.Response, error)

	// GetMaxRetriesFunc mocks the GetMaxRetries method.
	GetMaxRetriesFunc func() int

	// HeadFunc mocks the Head method.
	HeadFunc func(ctx context.Context, url string) (*http.Response, error)

	// PostFunc mocks the Post method.
	PostFunc func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error)

	// PostFormFunc mocks the PostForm method.
	PostFormFunc func(ctx context.Context, uri string, data url.Values) (*http.Response, error)

	// PutFunc mocks the Put method.
	PutFunc func(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error)

	// SetMaxRetriesFunc mocks the SetMaxRetries method.
	SetMaxRetriesFunc func(in1 int)

	// SetTimeoutFunc mocks the SetTimeout method.
	SetTimeoutFunc func(timeout time.Duration)

	// calls tracks calls to the methods.
	calls struct {
		// Do holds details about calls to the Do method.
		Do []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *http.Request
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
		}
		// GetMaxRetries holds details about calls to the GetMaxRetries method.
		GetMaxRetries []struct {
		}
		// Head holds details about calls to the Head method.
		Head []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
		}
		// Post holds details about calls to the Post method.
		Post []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
			// ContentType is the contentType argument value.
			ContentType string
			// Body is the body argument value.
			Body io.Reader
		}
		// PostForm holds details about calls to the PostForm method.
		PostForm []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URI is the uri argument value.
			URI string
			// Data is the data argument value.
			Data url.Values
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// URL is the url argument value.
			URL string
			// ContentType is the contentType argument value.
			ContentType string
			// Body is the body argument value.
			Body io.Reader
		}
		// SetMaxRetries holds details about calls to the SetMaxRetries method.
		SetMaxRetries []struct {
			// In1 is the in1 argument value.
			In1 int
		}
		// SetTimeout holds details about calls to the SetTimeout method.
		SetTimeout []struct {
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
	}
}

// Do calls DoFunc.
func (mock *ClienterMock) Do(ctx context.Context, req *http.Request) (*http.Response, error) {
	if mock.DoFunc == nil {
		panic("ClienterMock.DoFunc: method is nil but Clienter.Do was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *http.Request
	}{
		Ctx: ctx,
		Req: req,
	}
	lockClienterMockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	lockClienterMockDo.Unlock()
	return mock.DoFunc(ctx, req)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//     len(mockedClienter.DoCalls())
func (mock *ClienterMock) DoCalls() []struct {
	Ctx context.Context
	Req *http.Request
} {
	var calls []struct {
		Ctx context.Context
		Req *http.Request
	}
	lockClienterMockDo.RLock()
	calls = mock.calls.Do
	lockClienterMockDo.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *ClienterMock) Get(ctx context.Context, url string) (*http.Response, error) {
	if mock.GetFunc == nil {
		panic("ClienterMock.GetFunc: method is nil but Clienter.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		URL string
	}{
		Ctx: ctx,
		URL: url,
	}
	lockClienterMockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	lockClienterMockGet.Unlock()
	return mock.GetFunc(ctx, url)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//     len(mockedClienter.GetCalls())
func (mock *ClienterMock) GetCalls() []struct {
	Ctx context.Context
	URL string
} {
	var calls []struct {
		Ctx context.Context
		URL string
	}
	lockClienterMockGet.RLock()
	calls = mock.calls.Get
	lockClienterMockGet.RUnlock()
	return calls
}

// GetMaxRetries calls GetMaxRetriesFunc.
func (mock *ClienterMock) GetMaxRetries() int {
	if mock.GetMaxRetriesFunc == nil {
		panic("ClienterMock.GetMaxRetriesFunc: method is nil but Clienter.GetMaxRetries was just called")
	}
	callInfo := struct {
	}{}
	lockClienterMockGetMaxRetries.Lock()
	mock.calls.GetMaxRetries = append(mock.calls.GetMaxRetries, callInfo)
	lockClienterMockGetMaxRetries.Unlock()
	return mock.GetMaxRetriesFunc()
}

// GetMaxRetriesCalls gets all the calls that were made to GetMaxRetries.
// Check the length with:
//     len(mockedClienter.GetMaxRetriesCalls())
func (mock *ClienterMock) GetMaxRetriesCalls() []struct {
} {
	var calls []struct {
	}
	lockClienterMockGetMaxRetries.RLock()
	calls = mock.calls.GetMaxRetries
	lockClienterMockGetMaxRetries.RUnlock()
	return calls
}

// Head calls HeadFunc.
func (mock *ClienterMock) Head(ctx context.Context, url string) (*http.Response, error) {
	if mock.HeadFunc == nil {
		panic("ClienterMock.HeadFunc: method is nil but Clienter.Head was just called")
	}
	callInfo := struct {
		Ctx context.Context
		URL string
	}{
		Ctx: ctx,
		URL: url,
	}
	lockClienterMockHead.Lock()
	mock.calls.Head = append(mock.calls.Head, callInfo)
	lockClienterMockHead.Unlock()
	return mock.HeadFunc(ctx, url)
}

// HeadCalls gets all the calls that were made to Head.
// Check the length with:
//     len(mockedClienter.HeadCalls())
func (mock *ClienterMock) HeadCalls() []struct {
	Ctx context.Context
	URL string
} {
	var calls []struct {
		Ctx context.Context
		URL string
	}
	lockClienterMockHead.RLock()
	calls = mock.calls.Head
	lockClienterMockHead.RUnlock()
	return calls
}

// Post calls PostFunc.
func (mock *ClienterMock) Post(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
	if mock.PostFunc == nil {
		panic("ClienterMock.PostFunc: method is nil but Clienter.Post was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}{
		Ctx:         ctx,
		URL:         url,
		ContentType: contentType,
		Body:        body,
	}
	lockClienterMockPost.Lock()
	mock.calls.Post = append(mock.calls.Post, callInfo)
	lockClienterMockPost.Unlock()
	return mock.PostFunc(ctx, url, contentType, body)
}

// PostCalls gets all the calls that were made to Post.
// Check the length with:
//     len(mockedClienter.PostCalls())
func (mock *ClienterMock) PostCalls() []struct {
	Ctx         context.Context
	URL         string
	ContentType string
	Body        io.Reader
} {
	var calls []struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}
	lockClienterMockPost.RLock()
	calls = mock.calls.Post
	lockClienterMockPost.RUnlock()
	return calls
}

// PostForm calls PostFormFunc.
func (mock *ClienterMock) PostForm(ctx context.Context, uri string, data url.Values) (*http.Response, error) {
	if mock.PostFormFunc == nil {
		panic("ClienterMock.PostFormFunc: method is nil but Clienter.PostForm was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		URI  string
		Data url.Values
	}{
		Ctx:  ctx,
		URI:  uri,
		Data: data,
	}
	lockClienterMockPostForm.Lock()
	mock.calls.PostForm = append(mock.calls.PostForm, callInfo)
	lockClienterMockPostForm.Unlock()
	return mock.PostFormFunc(ctx, uri, data)
}

// PostFormCalls gets all the calls that were made to PostForm.
// Check the length with:
//     len(mockedClienter.PostFormCalls())
func (mock *ClienterMock) PostFormCalls() []struct {
	Ctx  context.Context
	URI  string
	Data url.Values
} {
	var calls []struct {
		Ctx  context.Context
		URI  string
		Data url.Values
	}
	lockClienterMockPostForm.RLock()
	calls = mock.calls.PostForm
	lockClienterMockPostForm.RUnlock()
	return calls
}

// Put calls PutFunc.
func (mock *ClienterMock) Put(ctx context.Context, url string, contentType string, body io.Reader) (*http.Response, error) {
	if mock.PutFunc == nil {
		panic("ClienterMock.PutFunc: method is nil but Clienter.Put was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}{
		Ctx:         ctx,
		URL:         url,
		ContentType: contentType,
		Body:        body,
	}
	lockClienterMockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	lockClienterMockPut.Unlock()
	return mock.PutFunc(ctx, url, contentType, body)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//     len(mockedClienter.PutCalls())
func (mock *ClienterMock) PutCalls() []struct {
	Ctx         context.Context
	URL         string
	ContentType string
	Body        io.Reader
} {
	var calls []struct {
		Ctx         context.Context
		URL         string
		ContentType string
		Body        io.Reader
	}
	lockClienterMockPut.RLock()
	calls = mock.calls.Put
	lockClienterMockPut.RUnlock()
	return calls
}

// SetMaxRetries calls SetMaxRetriesFunc.
func (mock *ClienterMock) SetMaxRetries(in1 int) {
	if mock.SetMaxRetriesFunc == nil {
		panic("ClienterMock.SetMaxRetriesFunc: method is nil but Clienter.SetMaxRetries was just called")
	}
	callInfo := struct {
		In1 int
	}{
		In1: in1,
	}
	lockClienterMockSetMaxRetries.Lock()
	mock.calls.SetMaxRetries = append(mock.calls.SetMaxRetries, callInfo)
	lockClienterMockSetMaxRetries.Unlock()
	mock.SetMaxRetriesFunc(in1)
}

// SetMaxRetriesCalls gets all the calls that were made to SetMaxRetries.
// Check the length with:
//     len(mockedClienter.SetMaxRetriesCalls())
func (mock *ClienterMock) SetMaxRetriesCalls() []struct {
	In1 int
} {
	var calls []struct {
		In1 int
	}
	lockClienterMockSetMaxRetries.RLock()
	calls = mock.calls.SetMaxRetries
	lockClienterMockSetMaxRetries.RUnlock()
	return calls
}

// SetTimeout calls SetTimeoutFunc.
func (mock *ClienterMock) SetTimeout(timeout time.Duration) {
	if mock.SetTimeoutFunc == nil {
		panic("ClienterMock.SetTimeoutFunc: method is nil but Clienter.SetTimeout was just called")
	}
	callInfo := struct {
		Timeout time.Duration
	}{
		Timeout: timeout,
	}
	lockClienterMockSetTimeout.Lock()
	mock.calls.SetTimeout = append(mock.calls.SetTimeout, callInfo)
	lockClienterMockSetTimeout.Unlock()
	mock.SetTimeoutFunc(timeout)
}

// SetTimeoutCalls gets all the calls that were made to SetTimeout.
// Check the length with:
//     len(mockedClienter.SetTimeoutCalls())
func (mock *ClienterMock) SetTimeoutCalls() []struct {
	Timeout time.Duration
} {
	var calls []struct {
		Timeout time.Duration
	}
	lockClienterMockSetTimeout.RLock()
	calls = mock.calls.SetTimeout
	lockClienterMockSetTimeout.RUnlock()
	return calls
}
